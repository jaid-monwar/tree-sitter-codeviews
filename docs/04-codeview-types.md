# Codeview Types

Comprehensive guide to understanding the different code representations generated by Comex.

## Table of Contents

- [Overview](#overview)
- [Abstract Syntax Tree (AST)](#abstract-syntax-tree-ast)
- [Control Flow Graph (CFG)](#control-flow-graph-cfg)
- [Data Flow Graph (DFG)](#data-flow-graph-dfg)
- [Concrete Syntax Tree (CST)](#concrete-syntax-tree-cst)
- [Statement-level DFG (SDFG)](#statement-level-dfg-sdfg)
- [Combined Graphs](#combined-graphs)
- [Comparison Table](#comparison-table)

## Overview

Comex generates multiple types of code representations (codeviews), each capturing different aspects of source code structure and behavior.

### Why Multiple Codeviews?

Different code representations capture different information:
- **AST**: Code structure and syntax hierarchy
- **CFG**: Execution paths and control flow
- **DFG**: Data dependencies and variable flow
- **Combined**: Comprehensive view with multiple perspectives

Research shows that combining multiple codeviews improves machine learning model performance for code-related tasks (see [CodeSAM paper](https://arxiv.org/abs/2411.14611)).

## Abstract Syntax Tree (AST)

### What is an AST?

An Abstract Syntax Tree represents the hierarchical syntactic structure of source code. It abstracts away parsing details (like semicolons and braces) while preserving the semantic structure.

### Example

**Code:**
```java
public class Test {
    public void method() {
        int x = 5;
        int y = x + 3;
    }
}
```

**AST Structure:**
```
program
└── class_declaration (Test)
    └── class_body
        └── method_declaration (method)
            └── block
                ├── local_variable_declaration
                │   ├── type: int
                │   ├── identifier: x
                │   └── literal: 5
                └── local_variable_declaration
                    ├── type: int
                    ├── identifier: y
                    └── binary_expression
                        ├── identifier: x
                        ├── operator: +
                        └── literal: 3
```

### Node Types

AST nodes represent different syntactic elements:

**Java Node Types:**
- `program` - Root node
- `class_declaration` - Class definition
- `method_declaration` - Method definition
- `local_variable_declaration` - Variable declaration
- `if_statement` - If conditional
- `for_statement` - For loop
- `while_statement` - While loop
- `binary_expression` - Binary operations (+, -, *, etc.)
- `identifier` - Variable/method names
- `literal` - Constant values

**C# Node Types:**
- `compilation_unit` - Root node
- `class_declaration` - Class definition
- `method_declaration` - Method definition
- `local_declaration_statement` - Variable declaration
- `if_statement` - If conditional
- `for_statement` - For loop
- `while_statement` - While loop
- `binary_expression` - Binary operations
- `identifier` - Variable/method names
- `literal_expression` - Constant values

### AST Customization

#### Collapsed Mode

**Without collapsing:**
```
x (line 3) → x (line 4) → x (line 5)
```

**With collapsing:**
```
x
```

**Use case:** Simplify graphs by merging duplicate variable nodes.

#### Minimized Mode (Blacklisting)

Remove noise from AST by blacklisting node types.

**Example:** Remove imports and packages
```python
blacklisted = ["import_declaration", "package_declaration"]
```

**Result:** Cleaner AST focused on code logic.

### When to Use AST

✅ **Good for:**
- Understanding code structure
- Syntax-based code analysis
- Template matching
- Code similarity detection
- Extracting class/method hierarchies

❌ **Not ideal for:**
- Analyzing execution flow
- Tracking variable values
- Finding data dependencies

### Generation

**CLI:**
```bash
comex --lang "java" --code-file test.java --graphs "ast"
```

**Python:**
```python
from comex.codeviews.AST.AST_driver import ASTDriver

driver = ASTDriver(
    src_language="java",
    src_code=code,
    output_file="ast.json",
    properties={
        "collapsed": False,
        "minimized": True,
        "blacklisted": ["import_declaration"]
    }
)
```

## Control Flow Graph (CFG)

### What is a CFG?

A Control Flow Graph represents all possible execution paths through a program. Nodes are code statements, and edges represent control flow (sequential execution, branching, loops).

### Example

**Code:**
```java
public void checkValue(int x) {
    if (x > 0) {
        System.out.println("Positive");
    } else {
        System.out.println("Negative");
    }
    System.out.println("Done");
}
```

**CFG Structure:**
```
[START]
   ↓
[1: if (x > 0)]
   ↓↘
   ↓  [3: System.out.println("Positive")]
   ↓    ↓
   ↘  ↙
   [4: System.out.println("Negative")]
     ↓
[5: System.out.println("Done")]
   ↓
[END]
```

### Node Types

CFG nodes represent statements:
- **Simple statements**: Variable assignments, method calls
- **Conditional statements**: if-else branches
- **Loop statements**: for, while, do-while
- **Jump statements**: return, break, continue
- **Special nodes**: START, END

### Edge Types

CFG edges indicate control flow:
- **Sequential**: Normal statement-to-statement flow
- **if_true**: True branch of conditional
- **if_false**: False branch of conditional
- **loop_entry**: Entering a loop
- **loop_back**: Looping back to condition
- **method_call**: Call to another method
- **return**: Return from method

### Example: Loop CFG

**Code:**
```java
for (int i = 0; i < 10; i++) {
    sum += i;
}
```

**CFG:**
```
[1: int i = 0]
   ↓
[2: i < 10] ─false→ [END]
   ↓ true
[3: sum += i]
   ↓
[4: i++]
   ↓
   (loop back to line 2)
```

### Language-Specific Implementation

CFG generation is **language-specific**:
- `CFG_java.py` - Java-specific CFG logic
- `CFG_csharp.py` - C#-specific CFG logic

Each handles language-specific constructs (e.g., Java's try-catch-finally vs C#'s using statements).

### When to Use CFG

✅ **Good for:**
- Analyzing execution paths
- Finding unreachable code
- Control flow analysis
- Complexity metrics (cyclomatic complexity)
- Test case generation
- Bug detection (null pointer, resource leaks)

❌ **Not ideal for:**
- Understanding data dependencies
- Variable value tracking

### Generation

**CLI:**
```bash
comex --lang "java" --code-file test.java --graphs "cfg"
```

**Python:**
```python
from comex.codeviews.CFG.CFG_driver import CFGDriver

driver = CFGDriver(
    src_language="java",
    src_code=code,
    output_file="cfg.json",
    properties={}
)
```

## Data Flow Graph (DFG)

### What is a DFG?

A Data Flow Graph tracks how data (variables) flow through a program. It shows where variables are defined, used, and how they depend on each other.

### Example

**Code:**
```java
int x = 5;
int y = x + 3;
int z = y * 2;
System.out.println(z);
```

**DFG Structure:**
```
[x] ──def──> [5]
 ↓
[y] ──def──> [x + 3] ──uses──> [x]
 ↓
[z] ──def──> [y * 2] ──uses──> [y]
 ↓
[println] ──uses──> [z]
```

### Node Types

DFG nodes represent:
- **Variables**: Identifiers (x, y, z)
- **Literals**: Constant values (5, 3, 2)
- **Expressions**: Operations (x + 3, y * 2)

### Edge Types

DFG edges show data relationships:
- **definition** (def): Variable is assigned a value
- **use**: Variable is read
- **computed_from**: Expression depends on variables
- **last_def**: Last definition of variable (if enabled)
- **last_use**: Last use of variable (if enabled)

### Statement-Level DFG (SDFG)

Comex uses **statement-level** DFG with **Reaching Definitions Analysis (RDA)**:
- Groups variable operations by statement
- Tracks which definitions reach each use
- More precise than token-level DFG

### Example with RDA

**Code:**
```java
int x = 1;  // Statement 1
x = 2;      // Statement 2
int y = x;  // Statement 3
```

**Reaching Definitions:**
- At line 3, `x` has reaching definition from line 2 (not line 1)
- `y` is defined using the value of `x` from line 2

### DFG Customization

#### Collapsed Mode

Merge duplicate variable nodes (same as AST).

#### Last Definition Tracking

**With `--last-def`:**
```python
dfg_config = {
    "last_def": True
}
```

Edges annotated with the line number of the last definition:
```
[y = x] ──uses──> [x] {last_def: line 2}
```

#### Last Use Tracking

**With `--last-use`:**
```python
dfg_config = {
    "last_use": True
}
```

Edges annotated with the line number of the last use:
```
[x = 5] ──def──> [x] {last_use: line 7}
```

### When to Use DFG

✅ **Good for:**
- Tracking variable dependencies
- Dead code elimination
- Variable renaming
- Slicing analysis
- Understanding data transformations
- Dependency analysis

❌ **Not ideal for:**
- Understanding control flow
- Branch analysis

### Generation

**CLI:**
```bash
comex --lang "java" --code-file test.java --graphs "dfg"
comex --lang "java" --code-file test.java --graphs "dfg" --last-def --last-use
```

**Python:**
```python
from comex.codeviews.DFG.DFG_driver import DFGDriver

driver = DFGDriver(
    src_language="java",
    src_code=code,
    output_file="dfg.json",
    properties={
        "DFG": {
            "collapsed": False,
            "statements": True,
            "last_def": True,
            "last_use": True
        }
    }
)
```

## Concrete Syntax Tree (CST)

### What is a CST?

A Concrete Syntax Tree (also called Parse Tree) represents the **exact** syntactic structure including all tokens (parentheses, semicolons, braces).

### Difference from AST

| Feature | AST | CST |
|---------|-----|-----|
| **Includes syntax tokens** | No | Yes |
| **Includes whitespace** | No | Yes |
| **Size** | Smaller | Larger |
| **Use case** | Semantic analysis | Exact reconstruction |

**Example:**

Code: `int x = 5;`

**CST:**
```
local_variable_declaration
├── primitive_type
│   └── "int"
├── variable_declarator
│   ├── identifier
│   │   └── "x"
│   ├── "="
│   └── decimal_integer_literal
│       └── "5"
└── ";"
```

**AST:**
```
local_variable_declaration
├── type: int
├── identifier: x
└── value: 5
```

### When to Use CST

✅ **Good for:**
- Code formatting tools
- Exact code reconstruction
- Syntax highlighting
- Pretty printing

❌ **Not ideal for:**
- Semantic analysis
- Most ML tasks (too detailed)

### Generation

CST is generated as an intermediate step but not typically used as a final output in Comex. The tree-sitter parser generates a CST, which is then converted to AST.

## Statement-level DFG (SDFG)

### What is SDFG?

Statement-level DFG combines DFG with **Reaching Definitions Analysis (RDA)** to create a more precise data flow representation.

### Features

1. **Statement Granularity**: Groups operations by statement
2. **RDA Integration**: Tracks which definitions reach each use
3. **More Accurate**: Handles multiple assignments to same variable

### Example

**Code:**
```java
int x = 1;
x = x + 1;
int y = x;
```

**Traditional DFG:**
```
x(line 1) → x(line 2) → x(line 2) → x(line 3) → y(line 3)
```

**SDFG with RDA:**
```
Statement 1: x = 1
  - defines: {x}

Statement 2: x = x + 1
  - uses: {x from line 1}
  - defines: {x}

Statement 3: y = x
  - uses: {x from line 2}
  - defines: {y}
```

### RDA Table

SDFG generates an RDA table showing reaching definitions:

| Statement | Variable | Reaching Definitions |
|-----------|----------|---------------------|
| 1 | x | {} |
| 2 | x | {1} |
| 3 | x | {2} |
| 3 | y | {} |

### When to Use SDFG

✅ **Good for:**
- Precise data flow analysis
- Compiler optimizations
- Research on data dependencies
- Advanced program analysis

SDFG is used internally when generating DFG with `statements: True` (default in Comex).

## Combined Graphs

### What are Combined Graphs?

Combined graphs merge multiple codeviews into a single NetworkX MultiDiGraph, providing a comprehensive representation.

### Available Combinations

Comex supports 15+ combinations. Common ones:

1. **AST + DFG**: Structure + Data Flow
2. **CFG + DFG**: Control Flow + Data Flow
3. **AST + CFG**: Structure + Control Flow
4. **AST + CFG + DFG**: All three views

### How Combination Works

Graphs are combined by:
1. Generating each codeview separately
2. Adding all nodes from each graph
3. Adding all edges from each graph
4. Preserving edge types (AST_edge, CFG_edge, DFG_edge)

**Result:** Single graph with multiple edge types.

### Example: CFG + DFG

**Code:**
```java
int x = 5;
int y = x + 3;
```

**CFG Edges:**
```
[line 1] → [line 2]
```

**DFG Edges:**
```
[x] → [y]
```

**Combined:**
```
[line 1: x=5] ─CFG→ [line 2: y=x+3]
     ↓
    [x] ─DFG→ [y]
```

### Node and Edge Attributes

Combined graphs preserve attributes from individual codeviews:

**Nodes:**
- May have AST attributes (node_type, syntax info)
- May have CFG attributes (statement line number)
- May have DFG attributes (variable info)

**Edges:**
- `edge_type`: "AST_edge", "CFG_edge", or "DFG_edge"
- Type-specific attributes (controlflow_type, dataflow_type, etc.)

### When to Use Combined Graphs

✅ **Good for:**
- Comprehensive code analysis
- Machine learning models requiring multiple views
- Research on multi-view graph representations
- Tasks needing both structure and flow information

### Generation

**CLI:**
```bash
comex --lang "java" --code-file test.java --graphs "ast,cfg,dfg"
```

**Python:**
```python
from comex.codeviews.combined_graph.combined_driver import CombinedDriver

codeviews = {
    "AST": {"exists": True, "collapsed": False, "minimized": False, "blacklisted": []},
    "CFG": {"exists": True},
    "DFG": {"exists": True, "collapsed": False, "minimized": False,
            "statements": True, "last_def": False, "last_use": False}
}

driver = CombinedDriver(
    src_language="java",
    src_code=code,
    output_file="combined.json",
    graph_format="all",
    codeviews=codeviews
)
```

## Comparison Table

| Feature | AST | CFG | DFG | Combined |
|---------|-----|-----|-----|----------|
| **Represents** | Syntax structure | Execution flow | Data dependencies | All above |
| **Nodes** | Syntax elements | Statements | Variables/values | Mixed |
| **Edges** | Parent-child | Control flow | Data flow | All types |
| **Captures control flow** | ❌ | ✅ | ❌ | ✅ |
| **Captures data flow** | ❌ | ❌ | ✅ | ✅ |
| **Captures syntax** | ✅ | ❌ | ❌ | ✅ |
| **Language-specific** | Partially | Yes | Partially | Yes |
| **Customizable** | Yes (collapse, blacklist) | No | Yes (collapse, RDA) | Yes |
| **Graph size** | Large | Medium | Small | Largest |
| **Use for ML** | ✅ | ✅ | ✅ | ✅✅ (best) |

## Choosing the Right Codeview

### For Structure Analysis
→ Use **AST**

### For Execution Path Analysis
→ Use **CFG**

### For Variable Tracking
→ Use **DFG**

### For Comprehensive Analysis
→ Use **Combined (AST + CFG + DFG)**

### For Machine Learning
→ Use **Combined** (research shows better performance)

### For Specific Tasks

| Task | Recommended Codeview |
|------|---------------------|
| Code clone detection | AST or AST+DFG |
| Bug detection | CFG or CFG+DFG |
| Code completion | AST |
| Program slicing | DFG |
| Vulnerability detection | CFG+DFG |
| Code translation | AST+CFG+DFG |
| Code search | AST+DFG |
| Complexity analysis | CFG |

## See Also

- [CLI Reference](02-cli-reference.md) - Command-line options
- [Python API](03-python-api.md) - Programmatic usage
- [Architecture](05-architecture.md) - How codeviews are generated
- [Examples](12-examples.md) - Real-world usage patterns
